{"$message_type":"diagnostic","message":"unused import: `ff::Field`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/public_inputs.rs","byte_start":59,"byte_end":68,"line_start":2,"line_end":2,"column_start":30,"column_end":39,"is_primary":true,"text":[{"text":"use halo2curves::{bn256::Fr, ff::Field};","highlight_start":30,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/public_inputs.rs","byte_start":57,"byte_end":68,"line_start":2,"line_end":2,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"use halo2curves::{bn256::Fr, ff::Field};","highlight_start":28,"highlight_end":39}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/public_inputs.rs","byte_start":47,"byte_end":48,"line_start":2,"line_end":2,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"use halo2curves::{bn256::Fr, ff::Field};","highlight_start":18,"highlight_end":19}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/public_inputs.rs","byte_start":68,"byte_end":69,"line_start":2,"line_end":2,"column_start":39,"column_end":40,"is_primary":true,"text":[{"text":"use halo2curves::{bn256::Fr, ff::Field};","highlight_start":39,"highlight_end":40}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `ff::Field`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/public_inputs.rs:2:30\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use halo2curves::{bn256::Fr, ff::Field};\n  \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"not all trait items implemented, missing: `Params`","code":{"code":"E0046","explanation":"Items are missing in a trait implementation.\n\nErroneous code example:\n\n```compile_fail,E0046\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {}\n// error: not all trait items implemented, missing: `foo`\n```\n\nWhen trying to make some type implement a trait `Foo`, you must, at minimum,\nprovide implementations for all of `Foo`'s required methods (meaning the\nmethods that do not have default implementations), as well as any required\ntrait items like associated types or constants. Example:\n\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo() {} // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/circuit.rs","byte_start":431,"byte_end":465,"line_start":20,"line_end":20,"column_start":1,"column_end":35,"is_primary":true,"text":[{"text":"impl Circuit<Fr> for FoldedCircuit {","highlight_start":1,"highlight_end":35}],"label":"missing `Params` in implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"implement the missing item: `type Params = /* Type */;`","code":null,"level":"help","spans":[{"file_name":"src/circuit.rs","byte_start":1887,"byte_end":1887,"line_start":63,"line_end":63,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"type Params = /* Type */;\n","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0046]\u001b[0m\u001b[1m: not all trait items implemented, missing: `Params`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/circuit.rs:20:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl Circuit<Fr> for FoldedCircuit {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmissing `Params` in implementation\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: implement the missing item: `type Params = /* Type */;`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":468,"byte_end":488,"line_start":22,"line_end":22,"column_start":32,"column_end":52,"is_primary":true,"text":[{"text":") -> Result<(ParamsKZG<Bn256>, ProvingKey<G1Affine>)> {","highlight_start":32,"highlight_end":52}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":1},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":1},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":1},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":1},{"text":"    > + Default","highlight_start":1,"highlight_end":1},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":1},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":1},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":1},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":1},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":1},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":1},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":1},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":1},{"text":"    > + Default","highlight_start":1,"highlight_end":1},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":1},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":1},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":1},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":1},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:22:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<(ParamsKZG<Bn256>, ProvingKey<G1Affine>)> {\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1206,"byte_end":1228,"line_start":42,"line_end":42,"column_start":32,"column_end":54,"is_primary":true,"text":[{"text":") -> Result<(ParamsKZG<Bn256>, VerifyingKey<G1Affine>)> {","highlight_start":32,"highlight_end":54}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:42:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<(ParamsKZG<Bn256>, VerifyingKey<G1Affine>)> {\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1405,"byte_end":1425,"line_start":47,"line_end":47,"column_start":65,"column_end":85,"is_primary":true,"text":[{"text":"fn read_params_and_pk(path: &Path) -> Result<(ParamsKZG<Bn256>, ProvingKey<G1Affine>)> {","highlight_start":65,"highlight_end":85}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:47:65\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn read_params_and_pk(path: &Path) -> Result<(ParamsKZG<Bn256>, ProvingKey<G1Affine>)> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1631,"byte_end":1651,"line_start":54,"line_end":54,"column_start":32,"column_end":52,"is_primary":true,"text":[{"text":") -> Result<(ParamsKZG<Bn256>, ProvingKey<G1Affine>)> {","highlight_start":32,"highlight_end":52}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:54:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<(ParamsKZG<Bn256>, ProvingKey<G1Affine>)> {\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1897,"byte_end":1919,"line_start":62,"line_end":62,"column_start":32,"column_end":54,"is_primary":true,"text":[{"text":") -> Result<(ParamsKZG<Bn256>, VerifyingKey<G1Affine>)> {","highlight_start":32,"highlight_end":54}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:62:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Result<(ParamsKZG<Bn256>, VerifyingKey<G1Affine>)> {\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":2132,"byte_end":2152,"line_start":68,"line_end":68,"column_start":69,"column_end":89,"is_primary":true,"text":[{"text":"fn write_params_and_pk(path: &Path, params: &ParamsKZG<Bn256>, pk: &ProvingKey<G1Affine>) -> Result<()> {","highlight_start":69,"highlight_end":89}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:68:69\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn write_params_and_pk(path: &Path, params: &ParamsKZG<Bn256>, pk: &ProvingKey<G1Affine>) -> Result<()> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":2370,"byte_end":2392,"line_start":75,"line_end":75,"column_start":69,"column_end":91,"is_primary":true,"text":[{"text":"fn write_params_and_vk(path: &Path, params: &ParamsKZG<Bn256>, vk: &VerifyingKey<G1Affine>) -> Result<()> {","highlight_start":69,"highlight_end":91}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:75:69\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn write_params_and_vk(path: &Path, params: &ParamsKZG<Bn256>, vk: &VerifyingKey<G1Affine>) -> Result<()> {\n   \u001b[1m\u001b[94m|\u001b[0m                                                                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 3 arguments but 4 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/circuit.rs","byte_start":1454,"byte_end":1479,"line_start":48,"line_end":48,"column_start":25,"column_end":50,"is_primary":false,"text":[{"text":"                        || format!(\"value_{row}\"),","highlight_start":25,"highlight_end":50}],"label":"unexpected argument #1 of type `{closure@src/circuit.rs:48:25: 48:27}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/circuit.rs","byte_start":1415,"byte_end":1428,"line_start":47,"line_end":47,"column_start":39,"column_end":52,"is_primary":true,"text":[{"text":"                    let cell = region.assign_advice(","highlight_start":39,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `Value<_>`, found closure","code":null,"level":"note","spans":[{"file_name":"src/circuit.rs","byte_start":1566,"byte_end":1589,"line_start":51,"line_end":51,"column_start":25,"column_end":48,"is_primary":true,"text":[{"text":"                        || Value::known(*value),","highlight_start":25,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected struct `halo2_axiom::circuit::Value<_>`\n  found closure `{closure@src/circuit.rs:51:25: 51:27}`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/circuit.rs","byte_start":6683,"byte_end":6696,"line_start":225,"line_end":225,"column_start":12,"column_end":25,"is_primary":true,"text":[{"text":"    pub fn assign_advice<'v>(","highlight_start":12,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use parentheses to call this closure","code":null,"level":"help","spans":[{"file_name":"src/circuit.rs","byte_start":1566,"byte_end":1566,"line_start":51,"line_end":51,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"                        || Value::known(*value),","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/circuit.rs","byte_start":1589,"byte_end":1589,"line_start":51,"line_end":51,"column_start":48,"column_end":48,"is_primary":true,"text":[{"text":"                        || Value::known(*value),","highlight_start":48,"highlight_end":48}],"label":null,"suggested_replacement":")()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"src/circuit.rs","byte_start":1454,"byte_end":1479,"line_start":48,"line_end":48,"column_start":25,"column_end":50,"is_primary":true,"text":[{"text":"                        || format!(\"value_{row}\"),","highlight_start":25,"highlight_end":50}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/circuit.rs","byte_start":1566,"byte_end":1589,"line_start":51,"line_end":51,"column_start":25,"column_end":48,"is_primary":true,"text":[{"text":"                        || Value::known(*value),","highlight_start":25,"highlight_end":48}],"label":null,"suggested_replacement":"/* to */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 3 arguments but 4 arguments were supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/circuit.rs:47:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let cell = region.assign_advice(\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m 48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         || format!(\"value_{row}\"),\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94munexpected argument #1 of type `{closure@src/circuit.rs:48:25: 48:27}`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `Value<_>`, found closure\n   \u001b[1m\u001b[94m--> \u001b[0msrc/circuit.rs:51:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         || Value::known(*value),\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mhalo2_axiom::circuit::Value<_>\u001b[0m`\n              found closure `\u001b[1m\u001b[35m{closure@src/circuit.rs:51:25: 51:27}\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/circuit.rs:225:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m225\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn assign_advice<'v>(\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call this closure\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 51\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                        \u001b[92m(\u001b[0m|| Value::known(*value)\u001b[92m)()\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[92m+\u001b[0m                       \u001b[92m+++\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 48\u001b[0m \u001b[92m~ \u001b[0m                        ,\n\u001b[1m\u001b[94m 49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         advice,\n\u001b[1m\u001b[94m 50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         row,\n\u001b[1m\u001b[94m 51\u001b[0m \u001b[92m~ \u001b[0m                        \u001b[92m/* to */\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be applied to values that implement `Try`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/circuit.rs","byte_start":1408,"byte_end":1613,"line_start":47,"line_end":52,"column_start":32,"column_end":23,"is_primary":true,"text":[{"text":"                    let cell = region.assign_advice(","highlight_start":32,"highlight_end":53},{"text":"                        || format!(\"value_{row}\"),","highlight_start":1,"highlight_end":51},{"text":"                        advice,","highlight_start":1,"highlight_end":32},{"text":"                        row,","highlight_start":1,"highlight_end":29},{"text":"                        || Value::known(*value),","highlight_start":1,"highlight_end":49},{"text":"                    )?;","highlight_start":1,"highlight_end":23}],"label":"the `?` operator cannot be applied to type `AssignedCell<&halo2_axiom::plonk::Assigned<halo2curves::bn256::Fr>, halo2curves::bn256::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/circuit.rs","byte_start":1408,"byte_end":1613,"line_start":47,"line_end":52,"column_start":32,"column_end":23,"is_primary":false,"text":[{"text":"                    let cell = region.assign_advice(","highlight_start":32,"highlight_end":53},{"text":"                        || format!(\"value_{row}\"),","highlight_start":1,"highlight_end":51},{"text":"                        advice,","highlight_start":1,"highlight_end":32},{"text":"                        row,","highlight_start":1,"highlight_end":29},{"text":"                        || Value::known(*value),","highlight_start":1,"highlight_end":49},{"text":"                    )?;","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Try` is not implemented for `AssignedCell<&halo2_axiom::plonk::Assigned<halo2curves::bn256::Fr>, halo2curves::bn256::Fr>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the `?` operator can only be applied to values that implement `Try`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/circuit.rs:47:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                       let cell = region.assign_advice(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________________________^\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         || format!(\"value_{row}\"),\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         advice,\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         row,\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         || Value::known(*value),\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     )?;\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mthe `?` operator cannot be applied to type `AssignedCell<&halo2_axiom::plonk::Assigned<halo2curves::bn256::Fr>, halo2curves::bn256::Fr>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `Try` is not implemented for `AssignedCell<&halo2_axiom::plonk::Assigned<halo2curves::bn256::Fr>, halo2curves::bn256::Fr>`\n\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be applied to values that implement `Try`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/circuit.rs","byte_start":1798,"byte_end":1854,"line_start":59,"line_end":59,"column_start":13,"column_end":69,"is_primary":true,"text":[{"text":"            layouter.constrain_instance(cell.cell(), instance, row)?;","highlight_start":13,"highlight_end":69}],"label":"the `?` operator cannot be applied to type `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/circuit.rs","byte_start":1798,"byte_end":1854,"line_start":59,"line_end":59,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            layouter.constrain_instance(cell.cell(), instance, row)?;","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Try` is not implemented for `()`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the `?` operator can only be applied to values that implement `Try`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/circuit.rs:59:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             layouter.constrain_instance(cell.cell(), instance, row)?;\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe `?` operator cannot be applied to type `()`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `Try` is not implemented for `()`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":551,"byte_end":583,"line_start":24,"line_end":24,"column_start":28,"column_end":60,"is_primary":true,"text":[{"text":"        let (params, pk) = read_params_and_pk(proving_path)?;","highlight_start":28,"highlight_end":60}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:24:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (params, pk) = read_params_and_pk(proving_path)?;\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":551,"byte_end":584,"line_start":24,"line_end":24,"column_start":28,"column_end":61,"is_primary":true,"text":[{"text":"        let (params, pk) = read_params_and_pk(proving_path)?;","highlight_start":28,"highlight_end":61}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":551,"byte_end":584,"line_start":24,"line_end":24,"column_start":28,"column_end":61,"is_primary":false,"text":[{"text":"        let (params, pk) = read_params_and_pk(proving_path)?;","highlight_start":28,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:24:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (params, pk) = read_params_and_pk(proving_path)?;\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":655,"byte_end":662,"line_start":26,"line_end":26,"column_start":32,"column_end":39,"is_primary":true,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":32,"highlight_end":39}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":645,"byte_end":654,"line_start":26,"line_end":26,"column_start":22,"column_end":31,"is_primary":false,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":22,"highlight_end":31}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_vk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5164,"byte_end":5173,"line_start":192,"line_end":192,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_vk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5323,"byte_end":5341,"line_start":198,"line_end":198,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_vk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:26:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let vk = keygen_vk(&params, blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_vk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:198:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_vk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_vk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":655,"byte_end":662,"line_start":26,"line_end":26,"column_start":32,"column_end":39,"is_primary":true,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":32,"highlight_end":39}],"label":"the trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":645,"byte_end":654,"line_start":26,"line_end":26,"column_start":22,"column_end":31,"is_primary":false,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":22,"highlight_end":31}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `halo2curves_axiom` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs","byte_start":242,"byte_end":270,"line_start":5,"line_end":5,"column_start":1,"column_end":29,"is_primary":true,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs","byte_start":2356,"byte_end":2384,"line_start":98,"line_end":98,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n  Ed25519\n  Ed25519Affine\n  halo2_axiom::halo2curves_axiom::bn256::Fq\n  halo2_axiom::halo2curves_axiom::bn256::Fq2\n  halo2_axiom::halo2curves_axiom::bn256::Fr\n  halo2_axiom::halo2curves_axiom::bn256::G1\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2\nand 24 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `halo2curves::bn256::G1Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_vk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5164,"byte_end":5173,"line_start":192,"line_end":192,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_vk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5323,"byte_end":5341,"line_start":198,"line_end":198,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_vk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:26:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let vk = keygen_vk(&params, blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `halo2curves_axiom` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs:5:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs:98:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n              Ed25519\n              Ed25519Affine\n              halo2_axiom::halo2curves_axiom::bn256::Fq\n              halo2_axiom::halo2curves_axiom::bn256::Fq2\n              halo2_axiom::halo2curves_axiom::bn256::Fr\n              halo2_axiom::halo2curves_axiom::bn256::G1\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2\n            and 24 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `halo2curves::bn256::G1Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_vk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:198:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_vk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_vk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":655,"byte_end":662,"line_start":26,"line_end":26,"column_start":32,"column_end":39,"is_primary":true,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":32,"highlight_end":39}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G2Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":645,"byte_end":654,"line_start":26,"line_end":26,"column_start":22,"column_end":31,"is_primary":false,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":22,"highlight_end":31}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_vk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5164,"byte_end":5173,"line_start":192,"line_end":192,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_vk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5323,"byte_end":5341,"line_start":198,"line_end":198,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_vk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:26:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let vk = keygen_vk(&params, blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G2Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_vk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:198:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_vk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_vk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":655,"byte_end":662,"line_start":26,"line_end":26,"column_start":32,"column_end":39,"is_primary":true,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":32,"highlight_end":39}],"label":"the trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G2Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":645,"byte_end":654,"line_start":26,"line_end":26,"column_start":22,"column_end":31,"is_primary":false,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":22,"highlight_end":31}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `halo2curves_axiom` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs","byte_start":242,"byte_end":270,"line_start":5,"line_end":5,"column_start":1,"column_end":29,"is_primary":true,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs","byte_start":2356,"byte_end":2384,"line_start":98,"line_end":98,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n  Ed25519\n  Ed25519Affine\n  halo2_axiom::halo2curves_axiom::bn256::Fq\n  halo2_axiom::halo2curves_axiom::bn256::Fq2\n  halo2_axiom::halo2curves_axiom::bn256::Fr\n  halo2_axiom::halo2curves_axiom::bn256::G1\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2\nand 24 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_vk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5164,"byte_end":5173,"line_start":192,"line_end":192,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_vk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5323,"byte_end":5341,"line_start":198,"line_end":198,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_vk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:26:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let vk = keygen_vk(&params, blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G2Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `halo2curves_axiom` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs:5:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs:98:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n              Ed25519\n              Ed25519Affine\n              halo2_axiom::halo2curves_axiom::bn256::Fq\n              halo2_axiom::halo2curves_axiom::bn256::Fq2\n              halo2_axiom::halo2curves_axiom::bn256::Fr\n              halo2_axiom::halo2curves_axiom::bn256::G1\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2\n            and 24 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_vk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:198:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_vk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_vk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":645,"byte_end":678,"line_start":26,"line_end":26,"column_start":22,"column_end":55,"is_primary":true,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":22,"highlight_end":55}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:26:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let vk = keygen_vk(&params, blank_circuit)?;\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":645,"byte_end":679,"line_start":26,"line_end":26,"column_start":22,"column_end":56,"is_primary":true,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":22,"highlight_end":56}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":645,"byte_end":679,"line_start":26,"line_end":26,"column_start":22,"column_end":56,"is_primary":false,"text":[{"text":"            let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":22,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:26:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let vk = keygen_vk(&params, blank_circuit)?;\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":738,"byte_end":741,"line_start":27,"line_end":27,"column_start":58,"column_end":61,"is_primary":true,"text":[{"text":"            write_params_and_vk(verifying_path, &params, &vk)?;","highlight_start":58,"highlight_end":61}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:27:58\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             write_params_and_vk(verifying_path, &params, &vk)?;\n   \u001b[1m\u001b[94m|\u001b[0m                                                          \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":693,"byte_end":743,"line_start":27,"line_end":27,"column_start":13,"column_end":63,"is_primary":true,"text":[{"text":"            write_params_and_vk(verifying_path, &params, &vk)?;","highlight_start":13,"highlight_end":63}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":693,"byte_end":743,"line_start":27,"line_end":27,"column_start":13,"column_end":63,"is_primary":false,"text":[{"text":"            write_params_and_vk(verifying_path, &params, &vk)?;","highlight_start":13,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:27:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             write_params_and_vk(verifying_path, &params, &vk)?;\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":763,"byte_end":765,"line_start":29,"line_end":29,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok((params, pk))","highlight_start":9,"highlight_end":11}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:29:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ok((params, pk))\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":763,"byte_end":779,"line_start":29,"line_end":29,"column_start":9,"column_end":25,"is_primary":true,"text":[{"text":"        Ok((params, pk))","highlight_start":9,"highlight_end":25}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:29:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ok((params, pk))\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":878,"byte_end":885,"line_start":32,"line_end":32,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":28,"highlight_end":35}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":868,"byte_end":877,"line_start":32,"line_end":32,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":18,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_vk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5164,"byte_end":5173,"line_start":192,"line_end":192,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_vk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5323,"byte_end":5341,"line_start":198,"line_end":198,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_vk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:32:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let vk = keygen_vk(&params, blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_vk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:198:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_vk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_vk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":878,"byte_end":885,"line_start":32,"line_end":32,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":28,"highlight_end":35}],"label":"the trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":868,"byte_end":877,"line_start":32,"line_end":32,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":18,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `halo2curves_axiom` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs","byte_start":242,"byte_end":270,"line_start":5,"line_end":5,"column_start":1,"column_end":29,"is_primary":true,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs","byte_start":2356,"byte_end":2384,"line_start":98,"line_end":98,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n  Ed25519\n  Ed25519Affine\n  halo2_axiom::halo2curves_axiom::bn256::Fq\n  halo2_axiom::halo2curves_axiom::bn256::Fq2\n  halo2_axiom::halo2curves_axiom::bn256::Fr\n  halo2_axiom::halo2curves_axiom::bn256::G1\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2\nand 24 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `halo2curves::bn256::G1Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_vk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5164,"byte_end":5173,"line_start":192,"line_end":192,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_vk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5323,"byte_end":5341,"line_start":198,"line_end":198,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_vk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:32:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let vk = keygen_vk(&params, blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `halo2curves_axiom` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs:5:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs:98:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n              Ed25519\n              Ed25519Affine\n              halo2_axiom::halo2curves_axiom::bn256::Fq\n              halo2_axiom::halo2curves_axiom::bn256::Fq2\n              halo2_axiom::halo2curves_axiom::bn256::Fr\n              halo2_axiom::halo2curves_axiom::bn256::G1\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2\n            and 24 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `halo2curves::bn256::G1Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_vk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:198:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_vk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_vk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":878,"byte_end":885,"line_start":32,"line_end":32,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":28,"highlight_end":35}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G2Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":868,"byte_end":877,"line_start":32,"line_end":32,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":18,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_vk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5164,"byte_end":5173,"line_start":192,"line_end":192,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_vk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5323,"byte_end":5341,"line_start":198,"line_end":198,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_vk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:32:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let vk = keygen_vk(&params, blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G2Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_vk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:198:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_vk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_vk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":878,"byte_end":885,"line_start":32,"line_end":32,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":28,"highlight_end":35}],"label":"the trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G2Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":868,"byte_end":877,"line_start":32,"line_end":32,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":18,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `halo2curves_axiom` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs","byte_start":242,"byte_end":270,"line_start":5,"line_end":5,"column_start":1,"column_end":29,"is_primary":true,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs","byte_start":2356,"byte_end":2384,"line_start":98,"line_end":98,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n  Ed25519\n  Ed25519Affine\n  halo2_axiom::halo2curves_axiom::bn256::Fq\n  halo2_axiom::halo2curves_axiom::bn256::Fq2\n  halo2_axiom::halo2curves_axiom::bn256::Fr\n  halo2_axiom::halo2curves_axiom::bn256::G1\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2\nand 24 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_vk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5164,"byte_end":5173,"line_start":192,"line_end":192,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_vk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":5323,"byte_end":5341,"line_start":198,"line_end":198,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_vk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:32:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let vk = keygen_vk(&params, blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G2Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `halo2curves_axiom` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs:5:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs:98:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n              Ed25519\n              Ed25519Affine\n              halo2_axiom::halo2curves_axiom::bn256::Fq\n              halo2_axiom::halo2curves_axiom::bn256::Fq2\n              halo2_axiom::halo2curves_axiom::bn256::Fr\n              halo2_axiom::halo2curves_axiom::bn256::G1\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2\n            and 24 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_vk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:198:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_vk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_vk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":868,"byte_end":901,"line_start":32,"line_end":32,"column_start":18,"column_end":51,"is_primary":true,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":18,"highlight_end":51}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:32:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let vk = keygen_vk(&params, blank_circuit)?;\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":868,"byte_end":902,"line_start":32,"line_end":32,"column_start":18,"column_end":52,"is_primary":true,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":18,"highlight_end":52}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":868,"byte_end":902,"line_start":32,"line_end":32,"column_start":18,"column_end":52,"is_primary":false,"text":[{"text":"        let vk = keygen_vk(&params, blank_circuit)?;","highlight_start":18,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:32:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let vk = keygen_vk(&params, blank_circuit)?;\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `clone` exists for struct `halo2_axiom::plonk::VerifyingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":943,"byte_end":948,"line_start":33,"line_end":33,"column_start":40,"column_end":45,"is_primary":true,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":40,"highlight_end":45}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1204,"byte_end":1243,"line_start":47,"line_end":47,"column_start":1,"column_end":40,"is_primary":false,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":1,"highlight_end":40}],"label":"doesn't satisfy `_: Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":10964,"byte_end":10965,"line_start":261,"line_end":261,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        }","highlight_start":9,"highlight_end":10}],"label":"doesn't satisfy `_: CurveAffine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":3288,"byte_end":3435,"line_start":84,"line_end":84,"column_start":9,"column_end":156,"is_primary":false,"text":[{"text":"        new_curve_impl!(($($privacy)*), $name, $name_affine, $base, $scalar, $generator, $constant_a, $constant_b, $curve_id, $hash_to_curve, $flag_config);","highlight_start":9,"highlight_end":156}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs","byte_start":1077,"byte_end":1392,"line_start":38,"line_end":51,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"new_curve_impl!(","highlight_start":1,"highlight_end":1},{"text":"    (pub),","highlight_start":1,"highlight_end":1},{"text":"    G1,","highlight_start":1,"highlight_end":1},{"text":"    G1Affine,","highlight_start":1,"highlight_end":1},{"text":"    Fq,","highlight_start":1,"highlight_end":1},{"text":"    Fr,","highlight_start":1,"highlight_end":1},{"text":"    (G1_GENERATOR_X,G1_GENERATOR_Y),","highlight_start":1,"highlight_end":1},{"text":"    G1_A,","highlight_start":1,"highlight_end":1},{"text":"    G1_B,","highlight_start":1,"highlight_end":1},{"text":"    \"bn256_g1\",","highlight_start":1,"highlight_end":1},{"text":"    |domain_prefix| crate::hash_to_curve::hash_to_curve(domain_prefix, G1::default_hash_to_curve_suite()),","highlight_start":1,"highlight_end":1},{"text":"    crate::serde::CompressedFlagConfig::TwoSpare,","highlight_start":1,"highlight_end":1},{"text":"    standard_sign","highlight_start":1,"highlight_end":1},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following trait bounds were not satisfied:\n`halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\nwhich is required by `halo2_axiom::plonk::VerifyingKey<halo2curves::bn256::G1Affine>: Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `clone` exists for struct `halo2_axiom::plonk::VerifyingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:33:40\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;\n   \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: Clone`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs:38:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m new_curve_impl!(\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     (pub),\n\u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1,\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1Affine,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     standard_sign\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: CurveAffine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n           `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\n           which is required by `halo2_axiom::plonk::VerifyingKey<halo2curves::bn256::G1Affine>: Clone`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":931,"byte_end":938,"line_start":33,"line_end":33,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":28,"highlight_end":35}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":921,"byte_end":930,"line_start":33,"line_end":33,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":18,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_pk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8018,"byte_end":8027,"line_start":280,"line_end":280,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_pk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8237,"byte_end":8255,"line_start":288,"line_end":288,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_pk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:33:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_pk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:288:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_pk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m288\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_pk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":931,"byte_end":938,"line_start":33,"line_end":33,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":28,"highlight_end":35}],"label":"the trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":921,"byte_end":930,"line_start":33,"line_end":33,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":18,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `halo2curves_axiom` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs","byte_start":242,"byte_end":270,"line_start":5,"line_end":5,"column_start":1,"column_end":29,"is_primary":true,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs","byte_start":2356,"byte_end":2384,"line_start":98,"line_end":98,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n  Ed25519\n  Ed25519Affine\n  halo2_axiom::halo2curves_axiom::bn256::Fq\n  halo2_axiom::halo2curves_axiom::bn256::Fq2\n  halo2_axiom::halo2curves_axiom::bn256::Fr\n  halo2_axiom::halo2curves_axiom::bn256::G1\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2\nand 24 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `halo2curves::bn256::G1Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_pk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8018,"byte_end":8027,"line_start":280,"line_end":280,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_pk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8237,"byte_end":8255,"line_start":288,"line_end":288,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_pk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:33:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `halo2curves_axiom` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs:5:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs:98:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n              Ed25519\n              Ed25519Affine\n              halo2_axiom::halo2curves_axiom::bn256::Fq\n              halo2_axiom::halo2curves_axiom::bn256::Fq2\n              halo2_axiom::halo2curves_axiom::bn256::Fr\n              halo2_axiom::halo2curves_axiom::bn256::G1\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2\n            and 24 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `halo2curves::bn256::G1Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_pk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:288:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_pk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m288\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_pk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":931,"byte_end":938,"line_start":33,"line_end":33,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":28,"highlight_end":35}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G2Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":921,"byte_end":930,"line_start":33,"line_end":33,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":18,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_pk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8018,"byte_end":8027,"line_start":280,"line_end":280,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_pk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8237,"byte_end":8255,"line_start":288,"line_end":288,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_pk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:33:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G2Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_pk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:288:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_pk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m288\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_pk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":931,"byte_end":938,"line_start":33,"line_end":33,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":28,"highlight_end":35}],"label":"the trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G2Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":921,"byte_end":930,"line_start":33,"line_end":33,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":18,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `halo2curves_axiom` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs","byte_start":242,"byte_end":270,"line_start":5,"line_end":5,"column_start":1,"column_end":29,"is_primary":true,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs","byte_start":2356,"byte_end":2384,"line_start":98,"line_end":98,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub trait SerdeObject: Sized {","highlight_start":1,"highlight_end":29}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n  Ed25519\n  Ed25519Affine\n  halo2_axiom::halo2curves_axiom::bn256::Fq\n  halo2_axiom::halo2curves_axiom::bn256::Fq2\n  halo2_axiom::halo2curves_axiom::bn256::Fr\n  halo2_axiom::halo2curves_axiom::bn256::G1\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2\nand 24 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_pk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8018,"byte_end":8027,"line_start":280,"line_end":280,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_pk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8237,"byte_end":8255,"line_start":288,"line_end":288,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    P: Params<'params, C> + Sync,","highlight_start":8,"highlight_end":26}],"label":"required by this bound in `keygen_pk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G2Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:33:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject` is not implemented for `halo2curves::bn256::G2Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `halo2curves_axiom` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-axiom-0.7.2/src/serde.rs:5:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/serde.rs:98:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait SerdeObject: Sized {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::halo2curves_axiom::serde::SerdeObject`:\n              Ed25519\n              Ed25519Affine\n              halo2_axiom::halo2curves_axiom::bn256::Fq\n              halo2_axiom::halo2curves_axiom::bn256::Fq2\n              halo2_axiom::halo2curves_axiom::bn256::Fr\n              halo2_axiom::halo2curves_axiom::bn256::G1\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2\n            and 24 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `halo2curves::bn256::G2Affine` to implement `halo2_axiom::helpers::SerdeCurveAffine`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ParamsKZG<halo2curves::bn256::Bn256>` to implement `Params<'_, halo2curves::bn256::G1Affine>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_pk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:288:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_pk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m288\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     P: Params<'params, C> + Sync,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_pk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":940,"byte_end":950,"line_start":33,"line_end":33,"column_start":37,"column_end":47,"is_primary":true,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":37,"highlight_end":47}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/keys.rs","byte_start":921,"byte_end":930,"line_start":33,"line_end":33,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":18,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `keygen_pk`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8018,"byte_end":8027,"line_start":280,"line_end":280,"column_start":8,"column_end":17,"is_primary":false,"text":[{"text":"pub fn keygen_pk<'params, C, P, ConcreteCircuit>(","highlight_start":8,"highlight_end":17}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs","byte_start":8180,"byte_end":8191,"line_start":286,"line_end":286,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"    C: CurveAffine,","highlight_start":8,"highlight_end":19}],"label":"required by this bound in `keygen_pk`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:33:37\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m          \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `keygen_pk`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk/keygen.rs:286:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn keygen_pk<'params, C, P, ConcreteCircuit>(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m286\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     C: CurveAffine,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `keygen_pk`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":921,"byte_end":966,"line_start":33,"line_end":33,"column_start":18,"column_end":63,"is_primary":true,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":18,"highlight_end":63}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:33:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":921,"byte_end":967,"line_start":33,"line_end":33,"column_start":18,"column_end":64,"is_primary":true,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":18,"highlight_end":64}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":921,"byte_end":967,"line_start":33,"line_end":33,"column_start":18,"column_end":64,"is_primary":false,"text":[{"text":"        let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;","highlight_start":18,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:33:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let pk = keygen_pk(&params, vk.clone(), blank_circuit)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1020,"byte_end":1023,"line_start":34,"line_end":34,"column_start":52,"column_end":55,"is_primary":true,"text":[{"text":"        write_params_and_pk(proving_path, &params, &pk)?;","highlight_start":52,"highlight_end":55}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:34:52\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         write_params_and_pk(proving_path, &params, &pk)?;\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":977,"byte_end":1025,"line_start":34,"line_end":34,"column_start":9,"column_end":57,"is_primary":true,"text":[{"text":"        write_params_and_pk(proving_path, &params, &pk)?;","highlight_start":9,"highlight_end":57}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":977,"byte_end":1025,"line_start":34,"line_end":34,"column_start":9,"column_end":57,"is_primary":false,"text":[{"text":"        write_params_and_pk(proving_path, &params, &pk)?;","highlight_start":9,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:34:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         write_params_and_pk(proving_path, &params, &pk)?;\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1080,"byte_end":1083,"line_start":35,"line_end":35,"column_start":54,"column_end":57,"is_primary":true,"text":[{"text":"        write_params_and_vk(verifying_path, &params, &vk)?;","highlight_start":54,"highlight_end":57}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:35:54\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         write_params_and_vk(verifying_path, &params, &vk)?;\n   \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1035,"byte_end":1085,"line_start":35,"line_end":35,"column_start":9,"column_end":59,"is_primary":true,"text":[{"text":"        write_params_and_vk(verifying_path, &params, &vk)?;","highlight_start":9,"highlight_end":59}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":1035,"byte_end":1085,"line_start":35,"line_end":35,"column_start":9,"column_end":59,"is_primary":false,"text":[{"text":"        write_params_and_vk(verifying_path, &params, &vk)?;","highlight_start":9,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:35:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         write_params_and_vk(verifying_path, &params, &vk)?;\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1095,"byte_end":1097,"line_start":36,"line_end":36,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok((params, pk))","highlight_start":9,"highlight_end":11}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:36:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ok((params, pk))\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1095,"byte_end":1111,"line_start":36,"line_end":36,"column_start":9,"column_end":25,"is_primary":true,"text":[{"text":"        Ok((params, pk))","highlight_start":9,"highlight_end":25}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:36:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ok((params, pk))\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1265,"byte_end":1292,"line_start":43,"line_end":43,"column_start":33,"column_end":60,"is_primary":true,"text":[{"text":"    let reader = BufReader::new(File::open(verifying_path)?);","highlight_start":33,"highlight_end":60}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":1265,"byte_end":1292,"line_start":43,"line_end":43,"column_start":33,"column_end":60,"is_primary":false,"text":[{"text":"    let reader = BufReader::new(File::open(verifying_path)?);","highlight_start":33,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:43:33\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let reader = BufReader::new(File::open(verifying_path)?);\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1299,"byte_end":1337,"line_start":44,"line_end":44,"column_start":5,"column_end":43,"is_primary":true,"text":[{"text":"    read_params_and_vk_from_reader(reader)","highlight_start":5,"highlight_end":43}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:44:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     read_params_and_vk_from_reader(reader)\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1462,"byte_end":1479,"line_start":48,"line_end":48,"column_start":33,"column_end":50,"is_primary":true,"text":[{"text":"    let reader = BufReader::new(File::open(path)?);","highlight_start":33,"highlight_end":50}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":1462,"byte_end":1479,"line_start":48,"line_end":48,"column_start":33,"column_end":50,"is_primary":false,"text":[{"text":"    let reader = BufReader::new(File::open(path)?);","highlight_start":33,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:48:33\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let reader = BufReader::new(File::open(path)?);\n    \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1486,"byte_end":1524,"line_start":49,"line_end":49,"column_start":5,"column_end":43,"is_primary":true,"text":[{"text":"    read_params_and_pk_from_reader(reader)","highlight_start":5,"highlight_end":43}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:49:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     read_params_and_pk_from_reader(reader)\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `read` found for struct `ParamsKZG<E>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1693,"byte_end":1697,"line_start":55,"line_end":55,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"    let params = ParamsKZG::<Bn256>::read(&mut reader)?;","highlight_start":38,"highlight_end":42}],"label":"function or associated item not found in `ParamsKZG<halo2curves::bn256::Bn256>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `ParamsKZG<halo2curves::bn256::Bn256>` consider using one of the following associated functions:\nParamsKZG::<E>::setup\nParamsKZG::<E>::read_custom","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/poly/kzg/commitment.rs","byte_start":1688,"byte_end":1736,"line_start":58,"line_end":58,"column_start":5,"column_end":53,"is_primary":true,"text":[{"text":"    pub fn setup<R: RngCore>(k: u32, rng: R) -> Self {","highlight_start":5,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/poly/kzg/commitment.rs","byte_start":5625,"byte_end":5801,"line_start":181,"line_end":184,"column_start":5,"column_end":39,"is_primary":true,"text":[{"text":"    pub fn read_custom<R: io::Read>(reader: &mut R, format: SerdeFormat) -> io::Result<Self>","highlight_start":5,"highlight_end":93},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        E::G1Affine: SerdeCurveAffine,","highlight_start":1,"highlight_end":39},{"text":"        E::G2Affine: SerdeCurveAffine,","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `read` found for struct `ParamsKZG<E>` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:55:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let params = ParamsKZG::<Bn256>::read(&mut reader)?;\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `ParamsKZG<halo2curves::bn256::Bn256>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `ParamsKZG<halo2curves::bn256::Bn256>` consider using one of the following associated functions:\n      ParamsKZG::<E>::setup\n      ParamsKZG::<E>::read_custom\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/poly/kzg/commitment.rs:58:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub fn setup<R: RngCore>(k: u32, rng: R) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m181\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m     pub fn read_custom<R: io::Read>(reader: &mut R, format: SerdeFormat) -> io::Result<Self>\n\u001b[1m\u001b[94m182\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     where\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         E::G1Affine: SerdeCurveAffine,\n\u001b[1m\u001b[94m184\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         E::G2Affine: SerdeCurveAffine,\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|______________________________________^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1673,"byte_end":1711,"line_start":55,"line_end":55,"column_start":18,"column_end":56,"is_primary":true,"text":[{"text":"    let params = ParamsKZG::<Bn256>::read(&mut reader)?;","highlight_start":18,"highlight_end":56}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":1673,"byte_end":1711,"line_start":55,"line_end":55,"column_start":18,"column_end":56,"is_primary":false,"text":[{"text":"    let params = ParamsKZG::<Bn256>::read(&mut reader)?;","highlight_start":18,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:55:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let params = ParamsKZG::<Bn256>::read(&mut reader)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1726,"byte_end":1748,"line_start":56,"line_end":56,"column_start":14,"column_end":36,"is_primary":true,"text":[{"text":"    let pk = ProvingKey::<G1Affine>::read(&mut reader)?;","highlight_start":14,"highlight_end":36}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:56:14\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let pk = ProvingKey::<G1Affine>::read(&mut reader)?;\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the function or associated item `read` exists for struct `ProvingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1750,"byte_end":1754,"line_start":56,"line_end":56,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"    let pk = ProvingKey::<G1Affine>::read(&mut reader)?;","highlight_start":38,"highlight_end":42}],"label":"function or associated item cannot be called on `ProvingKey<halo2curves::bn256::G1Affine>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":10964,"byte_end":10965,"line_start":261,"line_end":261,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        }","highlight_start":9,"highlight_end":10}],"label":"doesn't satisfy `_: CurveAffine`, `_: SerdeCurveAffine` or `_: SerdeObject`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":3288,"byte_end":3435,"line_start":84,"line_end":84,"column_start":9,"column_end":156,"is_primary":false,"text":[{"text":"        new_curve_impl!(($($privacy)*), $name, $name_affine, $base, $scalar, $generator, $constant_a, $constant_b, $curve_id, $hash_to_curve, $flag_config);","highlight_start":9,"highlight_end":156}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs","byte_start":1077,"byte_end":1392,"line_start":38,"line_end":51,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"new_curve_impl!(","highlight_start":1,"highlight_end":17},{"text":"    (pub),","highlight_start":1,"highlight_end":11},{"text":"    G1,","highlight_start":1,"highlight_end":8},{"text":"    G1Affine,","highlight_start":1,"highlight_end":14},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    (G1_GENERATOR_X,G1_GENERATOR_Y),","highlight_start":1,"highlight_end":37},{"text":"    G1_A,","highlight_start":1,"highlight_end":10},{"text":"    G1_B,","highlight_start":1,"highlight_end":10},{"text":"    \"bn256_g1\",","highlight_start":1,"highlight_end":16},{"text":"    |domain_prefix| crate::hash_to_curve::hash_to_curve(domain_prefix, G1::default_hash_to_curve_suite()),","highlight_start":1,"highlight_end":107},{"text":"    crate::serde::CompressedFlagConfig::TwoSpare,","highlight_start":1,"highlight_end":50},{"text":"    standard_sign","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":293,"line_start":12,"line_end":14,"column_start":1,"column_end":7,"is_primary":false,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":7}],"label":"doesn't satisfy `_: SerdeObject` or `_: SerdePrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":528,"line_start":12,"line_end":20,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",","highlight_start":1,"highlight_end":82},{"text":"    mul_gen = \"7\",","highlight_start":1,"highlight_end":19},{"text":"    zeta = \"30644e72e131a029048b6e193fd84104cc37a73fec2bc5e9b8ca0b2d36636f23\",","highlight_start":1,"highlight_end":79},{"text":"    from_uniform = [64, 48],","highlight_start":1,"highlight_end":29},{"text":"    endian = \"little\",","highlight_start":1,"highlight_end":23},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_field!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2derive-0.2.0/src/lib.rs","byte_start":81,"byte_end":157,"line_start":7,"line_end":7,"column_start":1,"column_end":77,"is_primary":false,"text":[{"text":"pub fn impl_field(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following trait bounds were not satisfied:\n`halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\nwhich is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n`halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\nwhich is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n`halo2curves::bn256::Fr: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\nwhich is required by `halo2curves::bn256::Fr: halo2_axiom::helpers::SerdePrimeField`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the function or associated item `read` exists for struct `ProvingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:56:38\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let pk = ProvingKey::<G1Affine>::read(&mut reader)?;\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item cannot be called on `ProvingKey<halo2curves::bn256::G1Affine>` due to unsatisfied trait bounds\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs:38:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m new_curve_impl!(\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     (pub),\n\u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1,\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1Affine,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     standard_sign\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: CurveAffine`, `_: SerdeCurveAffine` or `_: SerdeObject`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs:12:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m impl_field!(\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bn256_scalar,\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Fr,\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     endian = \"little\",\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: SerdeObject` or `_: SerdePrimeField`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n           `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\n           which is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n           `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\n           which is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n           `halo2curves::bn256::Fr: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\n           which is required by `halo2curves::bn256::Fr: halo2_axiom::helpers::SerdePrimeField`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1726,"byte_end":1768,"line_start":56,"line_end":56,"column_start":14,"column_end":56,"is_primary":true,"text":[{"text":"    let pk = ProvingKey::<G1Affine>::read(&mut reader)?;","highlight_start":14,"highlight_end":56}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":1726,"byte_end":1768,"line_start":56,"line_end":56,"column_start":14,"column_end":56,"is_primary":false,"text":[{"text":"    let pk = ProvingKey::<G1Affine>::read(&mut reader)?;","highlight_start":14,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:56:14\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let pk = ProvingKey::<G1Affine>::read(&mut reader)?;\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1774,"byte_end":1776,"line_start":57,"line_end":57,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok((params, pk))","highlight_start":5,"highlight_end":7}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:57:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok((params, pk))\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1774,"byte_end":1790,"line_start":57,"line_end":57,"column_start":5,"column_end":21,"is_primary":true,"text":[{"text":"    Ok((params, pk))","highlight_start":5,"highlight_end":21}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ProvingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":11365,"byte_end":11376,"line_start":315,"line_end":315,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"pub struct ProvingKey<C: CurveAffine> {","highlight_start":26,"highlight_end":37}],"label":"required by this bound in `ProvingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:57:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok((params, pk))\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m 98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m 73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m 74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m 75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m 81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n              Ed25519Affine\n              EpAffine\n              EqAffine\n              halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n              halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n              halo2_axiom::halo2curves_axiom::bn256::G1Affine\n              halo2_axiom::halo2curves_axiom::bn256::G2Affine\n              halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n            and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ProvingKey`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:315:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m315\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ProvingKey<C: CurveAffine> {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ProvingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `read` found for struct `ParamsKZG<E>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1961,"byte_end":1965,"line_start":63,"line_end":63,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"    let params = ParamsKZG::<Bn256>::read(&mut reader)?;","highlight_start":38,"highlight_end":42}],"label":"function or associated item not found in `ParamsKZG<halo2curves::bn256::Bn256>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `ParamsKZG<halo2curves::bn256::Bn256>` consider using one of the following associated functions:\nParamsKZG::<E>::setup\nParamsKZG::<E>::read_custom","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/poly/kzg/commitment.rs","byte_start":1688,"byte_end":1736,"line_start":58,"line_end":58,"column_start":5,"column_end":53,"is_primary":true,"text":[{"text":"    pub fn setup<R: RngCore>(k: u32, rng: R) -> Self {","highlight_start":5,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/poly/kzg/commitment.rs","byte_start":5625,"byte_end":5801,"line_start":181,"line_end":184,"column_start":5,"column_end":39,"is_primary":true,"text":[{"text":"    pub fn read_custom<R: io::Read>(reader: &mut R, format: SerdeFormat) -> io::Result<Self>","highlight_start":5,"highlight_end":93},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        E::G1Affine: SerdeCurveAffine,","highlight_start":1,"highlight_end":39},{"text":"        E::G2Affine: SerdeCurveAffine,","highlight_start":1,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `read` found for struct `ParamsKZG<E>` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:63:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let params = ParamsKZG::<Bn256>::read(&mut reader)?;\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `ParamsKZG<halo2curves::bn256::Bn256>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `ParamsKZG<halo2curves::bn256::Bn256>` consider using one of the following associated functions:\n      ParamsKZG::<E>::setup\n      ParamsKZG::<E>::read_custom\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/poly/kzg/commitment.rs:58:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub fn setup<R: RngCore>(k: u32, rng: R) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m181\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m     pub fn read_custom<R: io::Read>(reader: &mut R, format: SerdeFormat) -> io::Result<Self>\n\u001b[1m\u001b[94m182\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     where\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         E::G1Affine: SerdeCurveAffine,\n\u001b[1m\u001b[94m184\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         E::G2Affine: SerdeCurveAffine,\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|______________________________________^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1941,"byte_end":1979,"line_start":63,"line_end":63,"column_start":18,"column_end":56,"is_primary":true,"text":[{"text":"    let params = ParamsKZG::<Bn256>::read(&mut reader)?;","highlight_start":18,"highlight_end":56}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":1941,"byte_end":1979,"line_start":63,"line_end":63,"column_start":18,"column_end":56,"is_primary":false,"text":[{"text":"    let params = ParamsKZG::<Bn256>::read(&mut reader)?;","highlight_start":18,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:63:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let params = ParamsKZG::<Bn256>::read(&mut reader)?;\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1994,"byte_end":2018,"line_start":64,"line_end":64,"column_start":14,"column_end":38,"is_primary":true,"text":[{"text":"    let vk = VerifyingKey::<G1Affine>::read(&mut reader)?;","highlight_start":14,"highlight_end":38}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:64:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let vk = VerifyingKey::<G1Affine>::read(&mut reader)?;\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the function or associated item `read` exists for struct `halo2_axiom::plonk::VerifyingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":2020,"byte_end":2024,"line_start":64,"line_end":64,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"    let vk = VerifyingKey::<G1Affine>::read(&mut reader)?;","highlight_start":40,"highlight_end":44}],"label":"function or associated item cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":10964,"byte_end":10965,"line_start":261,"line_end":261,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        }","highlight_start":9,"highlight_end":10}],"label":"doesn't satisfy `_: CurveAffine`, `_: SerdeCurveAffine` or `_: SerdeObject`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":3288,"byte_end":3435,"line_start":84,"line_end":84,"column_start":9,"column_end":156,"is_primary":false,"text":[{"text":"        new_curve_impl!(($($privacy)*), $name, $name_affine, $base, $scalar, $generator, $constant_a, $constant_b, $curve_id, $hash_to_curve, $flag_config);","highlight_start":9,"highlight_end":156}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs","byte_start":1077,"byte_end":1392,"line_start":38,"line_end":51,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"new_curve_impl!(","highlight_start":1,"highlight_end":17},{"text":"    (pub),","highlight_start":1,"highlight_end":11},{"text":"    G1,","highlight_start":1,"highlight_end":8},{"text":"    G1Affine,","highlight_start":1,"highlight_end":14},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    (G1_GENERATOR_X,G1_GENERATOR_Y),","highlight_start":1,"highlight_end":37},{"text":"    G1_A,","highlight_start":1,"highlight_end":10},{"text":"    G1_B,","highlight_start":1,"highlight_end":10},{"text":"    \"bn256_g1\",","highlight_start":1,"highlight_end":16},{"text":"    |domain_prefix| crate::hash_to_curve::hash_to_curve(domain_prefix, G1::default_hash_to_curve_suite()),","highlight_start":1,"highlight_end":107},{"text":"    crate::serde::CompressedFlagConfig::TwoSpare,","highlight_start":1,"highlight_end":50},{"text":"    standard_sign","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":293,"line_start":12,"line_end":14,"column_start":1,"column_end":7,"is_primary":false,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":7}],"label":"doesn't satisfy `_: SerdeObject` or `_: SerdePrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":528,"line_start":12,"line_end":20,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",","highlight_start":1,"highlight_end":82},{"text":"    mul_gen = \"7\",","highlight_start":1,"highlight_end":19},{"text":"    zeta = \"30644e72e131a029048b6e193fd84104cc37a73fec2bc5e9b8ca0b2d36636f23\",","highlight_start":1,"highlight_end":79},{"text":"    from_uniform = [64, 48],","highlight_start":1,"highlight_end":29},{"text":"    endian = \"little\",","highlight_start":1,"highlight_end":23},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_field!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2derive-0.2.0/src/lib.rs","byte_start":81,"byte_end":157,"line_start":7,"line_end":7,"column_start":1,"column_end":77,"is_primary":false,"text":[{"text":"pub fn impl_field(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following trait bounds were not satisfied:\n`halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\nwhich is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n`halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\nwhich is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n`halo2curves::bn256::Fr: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\nwhich is required by `halo2curves::bn256::Fr: halo2_axiom::helpers::SerdePrimeField`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the function or associated item `read` exists for struct `halo2_axiom::plonk::VerifyingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:64:40\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let vk = VerifyingKey::<G1Affine>::read(&mut reader)?;\n   \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item cannot be called due to unsatisfied trait bounds\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs:38:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m new_curve_impl!(\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     (pub),\n\u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1,\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1Affine,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     standard_sign\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: CurveAffine`, `_: SerdeCurveAffine` or `_: SerdeObject`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs:12:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m impl_field!(\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bn256_scalar,\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Fr,\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     endian = \"little\",\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: SerdeObject` or `_: SerdePrimeField`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n           `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\n           which is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n           `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\n           which is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n           `halo2curves::bn256::Fr: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\n           which is required by `halo2curves::bn256::Fr: halo2_axiom::helpers::SerdePrimeField`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":1994,"byte_end":2038,"line_start":64,"line_end":64,"column_start":14,"column_end":58,"is_primary":true,"text":[{"text":"    let vk = VerifyingKey::<G1Affine>::read(&mut reader)?;","highlight_start":14,"highlight_end":58}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/keys.rs","byte_start":1994,"byte_end":2038,"line_start":64,"line_end":64,"column_start":14,"column_end":58,"is_primary":false,"text":[{"text":"    let vk = VerifyingKey::<G1Affine>::read(&mut reader)?;","highlight_start":14,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:64:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let vk = VerifyingKey::<G1Affine>::read(&mut reader)?;\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":2044,"byte_end":2046,"line_start":65,"line_end":65,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok((params, vk))","highlight_start":5,"highlight_end":7}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:65:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok((params, vk))\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":2044,"byte_end":2060,"line_start":65,"line_end":65,"column_start":5,"column_end":21,"is_primary":true,"text":[{"text":"    Ok((params, vk))","highlight_start":5,"highlight_end":21}],"label":"the trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there are multiple different versions of crate `pasta_curves` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs","byte_start":3342,"byte_end":3707,"line_start":90,"line_end":99,"column_start":1,"column_end":46,"is_primary":true,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs","byte_start":2772,"byte_end":3137,"line_start":72,"line_end":81,"column_start":1,"column_end":46,"is_primary":false,"text":[{"text":"pub trait CurveAffine:","highlight_start":1,"highlight_end":23},{"text":"    PrimeCurveAffine<","highlight_start":1,"highlight_end":22},{"text":"        Scalar = <Self as CurveAffine>::ScalarExt,","highlight_start":1,"highlight_end":51},{"text":"        Curve = <Self as CurveAffine>::CurveExt,","highlight_start":1,"highlight_end":49},{"text":"    > + Default","highlight_start":1,"highlight_end":16},{"text":"    + Add<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + Sub<Output = <Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":54},{"text":"    + ConditionallySelectable","highlight_start":1,"highlight_end":30},{"text":"    + ConstantTimeEq","highlight_start":1,"highlight_end":21},{"text":"    + From<<Self as PrimeCurveAffine>::Curve>","highlight_start":1,"highlight_end":46}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n  Ed25519Affine\n  EpAffine\n  EqAffine\n  halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n  halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n  halo2_axiom::halo2curves_axiom::bn256::G1Affine\n  halo2_axiom::halo2curves_axiom::bn256::G2Affine\n  halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\nand 6 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `halo2_axiom::plonk::VerifyingKey`","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs","byte_start":1231,"byte_end":1242,"line_start":47,"line_end":47,"column_start":28,"column_end":39,"is_primary":true,"text":[{"text":"pub struct VerifyingKey<C: CurveAffine> {","highlight_start":28,"highlight_end":39}],"label":"required by this bound in `VerifyingKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:65:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok((params, vk))\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `halo2_axiom::arithmetic::CurveAffine` is not implemented for `halo2curves::bn256::G1Affine`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `pasta_curves` in the dependency graph\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pasta_curves-0.5.1/src/arithmetic/curves.rs:90:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_____________________________________________^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/curve.rs:72:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub trait CurveAffine:\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PrimeCurveAffine<\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Scalar = <Self as CurveAffine>::ScalarExt,\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Curve = <Self as CurveAffine>::CurveExt,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + ConstantTimeEq\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     + From<<Self as PrimeCurveAffine>::Curve>\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________________________________-\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `halo2_axiom::arithmetic::CurveAffine`:\n             Ed25519Affine\n             EpAffine\n             EqAffine\n             halo2_axiom::halo2curves_axiom::bls12_381::G1Affine\n             halo2_axiom::halo2curves_axiom::bls12_381::G2Affine\n             halo2_axiom::halo2curves_axiom::bn256::G1Affine\n             halo2_axiom::halo2curves_axiom::bn256::G2Affine\n             halo2_axiom::halo2curves_axiom::grumpkin::G1Affine\n           and 6 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `halo2_axiom::plonk::VerifyingKey`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2-axiom-0.5.1/src/plonk.rs:47:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct VerifyingKey<C: CurveAffine> {\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `VerifyingKey`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `write` found for reference `&ParamsKZG<halo2curves::bn256::Bn256>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":2239,"byte_end":2244,"line_start":70,"line_end":70,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"    params.write(&mut writer)?;","highlight_start":12,"highlight_end":17}],"label":"method not found in `&ParamsKZG<halo2curves::bn256::Bn256>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `write` found for reference `&ParamsKZG<halo2curves::bn256::Bn256>` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:70:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     params.write(&mut writer)?;\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&ParamsKZG<halo2curves::bn256::Bn256>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `write` exists for reference `&ProvingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":2267,"byte_end":2272,"line_start":71,"line_end":71,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"    pk.write(&mut writer)?;","highlight_start":8,"highlight_end":13}],"label":"method cannot be called on `&ProvingKey<halo2curves::bn256::G1Affine>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":10964,"byte_end":10965,"line_start":261,"line_end":261,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        }","highlight_start":9,"highlight_end":10}],"label":"doesn't satisfy `_: CurveAffine`, `_: SerdeCurveAffine` or `_: SerdeObject`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":3288,"byte_end":3435,"line_start":84,"line_end":84,"column_start":9,"column_end":156,"is_primary":false,"text":[{"text":"        new_curve_impl!(($($privacy)*), $name, $name_affine, $base, $scalar, $generator, $constant_a, $constant_b, $curve_id, $hash_to_curve, $flag_config);","highlight_start":9,"highlight_end":156}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs","byte_start":1077,"byte_end":1392,"line_start":38,"line_end":51,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"new_curve_impl!(","highlight_start":1,"highlight_end":17},{"text":"    (pub),","highlight_start":1,"highlight_end":11},{"text":"    G1,","highlight_start":1,"highlight_end":8},{"text":"    G1Affine,","highlight_start":1,"highlight_end":14},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    (G1_GENERATOR_X,G1_GENERATOR_Y),","highlight_start":1,"highlight_end":37},{"text":"    G1_A,","highlight_start":1,"highlight_end":10},{"text":"    G1_B,","highlight_start":1,"highlight_end":10},{"text":"    \"bn256_g1\",","highlight_start":1,"highlight_end":16},{"text":"    |domain_prefix| crate::hash_to_curve::hash_to_curve(domain_prefix, G1::default_hash_to_curve_suite()),","highlight_start":1,"highlight_end":107},{"text":"    crate::serde::CompressedFlagConfig::TwoSpare,","highlight_start":1,"highlight_end":50},{"text":"    standard_sign","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":293,"line_start":12,"line_end":14,"column_start":1,"column_end":7,"is_primary":false,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":7}],"label":"doesn't satisfy `_: SerdeObject` or `_: SerdePrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":528,"line_start":12,"line_end":20,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",","highlight_start":1,"highlight_end":82},{"text":"    mul_gen = \"7\",","highlight_start":1,"highlight_end":19},{"text":"    zeta = \"30644e72e131a029048b6e193fd84104cc37a73fec2bc5e9b8ca0b2d36636f23\",","highlight_start":1,"highlight_end":79},{"text":"    from_uniform = [64, 48],","highlight_start":1,"highlight_end":29},{"text":"    endian = \"little\",","highlight_start":1,"highlight_end":23},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_field!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2derive-0.2.0/src/lib.rs","byte_start":81,"byte_end":157,"line_start":7,"line_end":7,"column_start":1,"column_end":77,"is_primary":false,"text":[{"text":"pub fn impl_field(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following trait bounds were not satisfied:\n`halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\nwhich is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n`halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\nwhich is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n`halo2curves::bn256::Fr: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\nwhich is required by `halo2curves::bn256::Fr: halo2_axiom::helpers::SerdePrimeField`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `write` exists for reference `&ProvingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:71:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pk.write(&mut writer)?;\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `&ProvingKey<halo2curves::bn256::G1Affine>` due to unsatisfied trait bounds\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs:38:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m new_curve_impl!(\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     (pub),\n\u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1,\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1Affine,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     standard_sign\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: CurveAffine`, `_: SerdeCurveAffine` or `_: SerdeObject`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs:12:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m impl_field!(\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bn256_scalar,\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Fr,\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     endian = \"little\",\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: SerdeObject` or `_: SerdePrimeField`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n           `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\n           which is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n           `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\n           which is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n           `halo2curves::bn256::Fr: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\n           which is required by `halo2curves::bn256::Fr: halo2_axiom::helpers::SerdePrimeField`\n\n"}
{"$message_type":"diagnostic","message":"no method named `write` found for reference `&ParamsKZG<halo2curves::bn256::Bn256>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":2479,"byte_end":2484,"line_start":77,"line_end":77,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"    params.write(&mut writer)?;","highlight_start":12,"highlight_end":17}],"label":"method not found in `&ParamsKZG<halo2curves::bn256::Bn256>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `write` found for reference `&ParamsKZG<halo2curves::bn256::Bn256>` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:77:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     params.write(&mut writer)?;\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&ParamsKZG<halo2curves::bn256::Bn256>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `write` exists for reference `&halo2_axiom::plonk::VerifyingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/keys.rs","byte_start":2507,"byte_end":2512,"line_start":78,"line_end":78,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"    vk.write(&mut writer)?;","highlight_start":8,"highlight_end":13}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":10964,"byte_end":10965,"line_start":261,"line_end":261,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        }","highlight_start":9,"highlight_end":10}],"label":"doesn't satisfy `_: CurveAffine`, `_: SerdeCurveAffine` or `_: SerdeObject`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":3288,"byte_end":3435,"line_start":84,"line_end":84,"column_start":9,"column_end":156,"is_primary":false,"text":[{"text":"        new_curve_impl!(($($privacy)*), $name, $name_affine, $base, $scalar, $generator, $constant_a, $constant_b, $curve_id, $hash_to_curve, $flag_config);","highlight_start":9,"highlight_end":156}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs","byte_start":1077,"byte_end":1392,"line_start":38,"line_end":51,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"new_curve_impl!(","highlight_start":1,"highlight_end":17},{"text":"    (pub),","highlight_start":1,"highlight_end":11},{"text":"    G1,","highlight_start":1,"highlight_end":8},{"text":"    G1Affine,","highlight_start":1,"highlight_end":14},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    (G1_GENERATOR_X,G1_GENERATOR_Y),","highlight_start":1,"highlight_end":37},{"text":"    G1_A,","highlight_start":1,"highlight_end":10},{"text":"    G1_B,","highlight_start":1,"highlight_end":10},{"text":"    \"bn256_g1\",","highlight_start":1,"highlight_end":16},{"text":"    |domain_prefix| crate::hash_to_curve::hash_to_curve(domain_prefix, G1::default_hash_to_curve_suite()),","highlight_start":1,"highlight_end":107},{"text":"    crate::serde::CompressedFlagConfig::TwoSpare,","highlight_start":1,"highlight_end":50},{"text":"    standard_sign","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"new_curve_impl!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/derive/curve.rs","byte_start":2254,"byte_end":2281,"line_start":53,"line_end":53,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! new_curve_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":293,"line_start":12,"line_end":14,"column_start":1,"column_end":7,"is_primary":false,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":7}],"label":"doesn't satisfy `_: SerdeObject` or `_: SerdePrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":528,"line_start":12,"line_end":20,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",","highlight_start":1,"highlight_end":82},{"text":"    mul_gen = \"7\",","highlight_start":1,"highlight_end":19},{"text":"    zeta = \"30644e72e131a029048b6e193fd84104cc37a73fec2bc5e9b8ca0b2d36636f23\",","highlight_start":1,"highlight_end":79},{"text":"    from_uniform = [64, 48],","highlight_start":1,"highlight_end":29},{"text":"    endian = \"little\",","highlight_start":1,"highlight_end":23},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_field!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2derive-0.2.0/src/lib.rs","byte_start":81,"byte_end":157,"line_start":7,"line_end":7,"column_start":1,"column_end":77,"is_primary":false,"text":[{"text":"pub fn impl_field(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following trait bounds were not satisfied:\n`halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\nwhich is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n`halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\nwhich is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n`halo2curves::bn256::Fr: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\nwhich is required by `halo2curves::bn256::Fr: halo2_axiom::helpers::SerdePrimeField`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `write` exists for reference `&halo2_axiom::plonk::VerifyingKey<halo2curves::bn256::G1Affine>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/keys.rs:78:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       vk.write(&mut writer)?;\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/curve.rs:38:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m new_curve_impl!(\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     (pub),\n\u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1,\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     G1Affine,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     standard_sign\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: CurveAffine`, `_: SerdeCurveAffine` or `_: SerdeObject`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs:12:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m impl_field!(\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     bn256_scalar,\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Fr,\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     endian = \"little\",\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: SerdeObject` or `_: SerdePrimeField`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n           `halo2curves::bn256::G1Affine: halo2_axiom::arithmetic::CurveAffine`\n           which is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n           `halo2curves::bn256::G1Affine: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\n           which is required by `halo2curves::bn256::G1Affine: halo2_axiom::helpers::SerdeCurveAffine`\n           `halo2curves::bn256::Fr: halo2_axiom::halo2curves_axiom::serde::SerdeObject`\n           which is required by `halo2curves::bn256::Fr: halo2_axiom::helpers::SerdePrimeField`\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `from_bytes_wide` found for struct `halo2curves::bn256::Fr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/public_inputs.rs","byte_start":1513,"byte_end":1528,"line_start":49,"line_end":49,"column_start":12,"column_end":27,"is_primary":true,"text":[{"text":"    Ok(Fr::from_bytes_wide(&wide))","highlight_start":12,"highlight_end":27}],"label":"function or associated item not found in `halo2curves::bn256::Fr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `halo2curves::bn256::Fr` consider using one of the following associated functions:\nhalo2curves::bn256::Fr::zero\nhalo2curves::bn256::Fr::one\nhalo2curves::bn256::Fr::from_raw","code":null,"level":"note","spans":[{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":528,"line_start":12,"line_end":20,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",","highlight_start":1,"highlight_end":82},{"text":"    mul_gen = \"7\",","highlight_start":1,"highlight_end":19},{"text":"    zeta = \"30644e72e131a029048b6e193fd84104cc37a73fec2bc5e9b8ca0b2d36636f23\",","highlight_start":1,"highlight_end":79},{"text":"    from_uniform = [64, 48],","highlight_start":1,"highlight_end":29},{"text":"    endian = \"little\",","highlight_start":1,"highlight_end":23},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs","byte_start":256,"byte_end":528,"line_start":12,"line_end":20,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_field!(","highlight_start":1,"highlight_end":13},{"text":"    bn256_scalar,","highlight_start":1,"highlight_end":18},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",","highlight_start":1,"highlight_end":82},{"text":"    mul_gen = \"7\",","highlight_start":1,"highlight_end":19},{"text":"    zeta = \"30644e72e131a029048b6e193fd84104cc37a73fec2bc5e9b8ca0b2d36636f23\",","highlight_start":1,"highlight_end":79},{"text":"    from_uniform = [64, 48],","highlight_start":1,"highlight_end":29},{"text":"    endian = \"little\",","highlight_start":1,"highlight_end":23},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_field!","def_site_span":{"file_name":"/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2derive-0.2.0/src/lib.rs","byte_start":81,"byte_end":157,"line_start":7,"line_end":7,"column_start":1,"column_end":77,"is_primary":false,"text":[{"text":"pub fn impl_field(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"there is an associated function `from_bytes` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/public_inputs.rs","byte_start":1513,"byte_end":1528,"line_start":49,"line_end":49,"column_start":12,"column_end":27,"is_primary":true,"text":[{"text":"    Ok(Fr::from_bytes_wide(&wide))","highlight_start":12,"highlight_end":27}],"label":null,"suggested_replacement":"from_bytes","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `from_bytes_wide` found for struct `halo2curves::bn256::Fr` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/public_inputs.rs:49:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(Fr::from_bytes_wide(&wide))\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `halo2curves::bn256::Fr`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `halo2curves::bn256::Fr` consider using one of the following associated functions:\n      halo2curves::bn256::Fr::zero\n      halo2curves::bn256::Fr::one\n      halo2curves::bn256::Fr::from_raw\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/parallel/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/halo2curves-0.9.0/src/bn256/fr.rs:12:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m impl_field!(\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     bn256_scalar,\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     Fr,\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     modulus = \"30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\",\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[92m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     endian = \"little\",\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `impl_field` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an associated function `from_bytes` with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[91m- \u001b[0m    Ok(Fr::\u001b[91mfrom_bytes_wide\u001b[0m(&wide))\n\u001b[1m\u001b[94m49\u001b[0m \u001b[92m+ \u001b[0m    Ok(Fr::\u001b[92mfrom_bytes\u001b[0m(&wide))\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 66 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 66 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0046, E0061, E0277, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0046, E0061, E0277, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0046`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0046`.\u001b[0m\n"}
